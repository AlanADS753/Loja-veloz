ğŸš€ Projeto Loja Veloz - Cloud Native & DevOps
Este repositÃ³rio contÃ©m a implementaÃ§Ã£o da arquitetura de microsserviÃ§os para a Loja Veloz, focada em escalabilidade, resiliÃªncia e seguranÃ§a. O projeto abrange desde o desenvolvimento local com Docker Compose atÃ© a orquestraÃ§Ã£o profissional com Kubernetes e automaÃ§Ã£o via CI/CD.

ğŸ—ï¸ Arquitetura do Sistema
A aplicaÃ§Ã£o Ã© composta por 4 microsserviÃ§os independentes:

API Gateway: Ponto de entrada, responsÃ¡vel pelo roteamento e Tracing DistribuÃ­do.

ServiÃ§o de Pedidos: Core business, integrado ao banco de dados PostgreSQL.

ServiÃ§o de Estoque: Controle de inventÃ¡rio.

ServiÃ§o de Pagamentos: Processamento de transaÃ§Ãµes.

ğŸ› ï¸ Tecnologias Utilizadas
Runtime: Node.js 18 (Alpine Images)

ContainerizaÃ§Ã£o: Docker & Docker Compose

OrquestraÃ§Ã£o: Kubernetes (Minikube/EKS)

Infraestrutura como CÃ³digo: Terraform

CI/CD: GitHub Actions

Banco de Dados: PostgreSQL

ğŸš€ Como Executar o Projeto
1. Ambiente Local (Docker Compose)
Para subir todos os serviÃ§os, redes e volumes com um Ãºnico comando:

Bash
docker-compose up --build
Acesse o Gateway em: http://localhost:8080

2. Ambiente de ProduÃ§Ã£o (Kubernetes)
Certifique-se de que o seu cluster (Minikube) estÃ¡ rodando e execute a aplicaÃ§Ã£o dos manifestos na ordem correta:

Bash
# 1. ConfiguraÃ§Ãµes e Segredos
kubectl apply -f k8s/postgres-secrets.yaml
kubectl apply -f k8s/pedidos-configmap.yaml

# 2. Infraestrutura de Banco
kubectl apply -f k8s/postgres-deployment.yaml

# 3. MicrosserviÃ§os
kubectl apply -f k8s/api-gateway.yaml
kubectl apply -f k8s/pedidos.yaml
kubectl apply -f k8s/estoque.yaml
kubectl apply -f k8s/pagamentos.yaml

# 4. Escalonamento AutomÃ¡tico
kubectl apply -f k8s/hpa.yaml
ğŸ›¡ï¸ Boas PrÃ¡ticas Implementadas
ConteinerizaÃ§Ã£o e SeguranÃ§a
User Non-Root: Todos os Dockerfiles utilizam USER appuser para evitar privilÃ©gios elevados.

Imagens Enxutas: Uso de imagens base alpine e limpeza de cache do NPM para reduzir a superfÃ­cie de ataque.

Secrets: Credenciais de banco de dados nunca estÃ£o no cÃ³digo; sÃ£o injetadas via Kubernetes Secrets.

ResiliÃªncia e Escala
Probes: ImplementaÃ§Ã£o de Liveness e Readiness probes para garantir o self-healing do cluster.

EstratÃ©gia de Deploy: Configurado como RollingUpdate para garantir zero downtime durante atualizaÃ§Ãµes.

HPA (Horizontal Pod Autoscaler): Configurado para escalar o serviÃ§o de Pedidos automaticamente caso o uso de CPU exceda 50%.

Observabilidade e Tracing
Tracing DistribuÃ­do: ImplementaÃ§Ã£o manual de x-trace-id que correlaciona logs entre o Gateway e os serviÃ§os internos.

Logs Estruturados: SaÃ­da padronizada no console para captura por agregadores de logs.

ğŸ¤– CI/CD Pipeline
Nosso pipeline no GitHub Actions realiza automaticamente:

Lint & Test: ValidaÃ§Ã£o da qualidade do cÃ³digo.

Build & Scan: CriaÃ§Ã£o das imagens Docker e varredura de vulnerabilidades.

Push: PublicaÃ§Ã£o das imagens versionadas no Docker Hub/Registry.

ğŸ“ Estrutura do RepositÃ³rio
Plaintext
â”œâ”€â”€ terraform/          # IaC para provisionamento do cluster
â”œâ”€â”€ k8s/                # Manifestos de Deployment, Service, HPA e Secrets
â”œâ”€â”€ api-gateway/        # CÃ³digo fonte e Dockerfile do Gateway
â”œâ”€â”€ pedidos/            # CÃ³digo fonte e Dockerfile de Pedidos
â”œâ”€â”€ estoque/            # CÃ³digo fonte e Dockerfile de Estoque
â”œâ”€â”€ pagamentos/         # CÃ³digo fonte e Dockerfile de Pagamentos
â”œâ”€â”€ docker-compose.yml  # OrquestraÃ§Ã£o local
â””â”€â”€ .github/workflows/  # DefiniÃ§Ã£o do pipeline de CI/CD